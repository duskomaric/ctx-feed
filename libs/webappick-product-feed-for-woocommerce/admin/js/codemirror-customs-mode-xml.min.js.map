{"version":3,"sources":["codemirror-customs-mode-xml.js"],"names":["_typeof","Symbol","iterator","o","exports","constructor","prototype","module","require","CodeMirror","mod","define","amd","htmlConfig","autoSelfClosers","contextGrabbers","implicitlyClosed","th","tbody","allowUnquoted","caseFold","tr","allowMissingTagName","xmlConfig","defineMode","defaults","prop","stream","state","editorConf","config_","ch","setStyle","indentUnit","chain","tokenize","parser","config","inText","eatWhile","next","eat","inBlock","match","doctype","depth","tagName","isInText","toLowerCase","Context","startOfLine","type","doNotIndent","hasOwnProperty","context","curlTag","ok","allowMissing","exec","String","string","length","inAttribute","baseState","quote","closure","inTag","isInAttribute","column","eol","terminator","style","popContext","noIndent","this","tagNameState","prev","nextTagName","tagStart","closeTagNameState","current","closeState","matchClosing","closeStateErr","parentTagName","attrValueState","_stream","attrContinuedState","attrEqState","lower","maybePopContext","indented","baseIndent","attrState","indent","tagAfter","indentation","textAfter","fullLine","startState","stringStartCol","Pass","electricInput","blockCommentEnd","token","xmlCurrentTag","name","close","defineMIME","mimeModes","grabbers"],"mappings":"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","file":"codemirror-customs-mode-xml.min.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n      'track': true, 'wbr': true, 'menuitem': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n      'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n      'th': true, 'tr': true,\n    },\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n        'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n        'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n        'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n        'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {\"pre\": true},\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  }\n\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    allowMissingTagName: false,\n    caseFold: false\n  }\n\n  CodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n    var indentUnit = editorConf.indentUnit\n    var config = {}\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n    for (var prop in defaults) config[prop] = defaults[prop]\n    for (var prop in config_) config[prop] = config_[prop]\n\n    // Return variables for tokenizers\n    var type, setStyle;\n\n    function inText(stream, state) {\n\n      function chain(parser) {\n        state.tokenize = parser;\n\n        return parser(stream, state);\n      }\n\n      var ch = stream.next();\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n            else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      }\n      else if (ch == \"{\") {\n        /*eslint-disable-next-line*///\n        const curlTag = ( /{{([^}}]+)}/gi.exec(String (stream?.string || '')) || []).length > 0 || false;\n        if (curlTag)\n          return chain(inBlock(\"a-tom\", \"}}\"));\n\n      }\n      else if (ch == \"&\") {\n        var ok;\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n    inText.isInText = true;\n\n    function inTag(stream, state) {\n      var ch = stream.next();\n      if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      }\n      else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      }\n\n      else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      }\n      else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n\n    function inAttribute(quote) {\n      var closure = function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n        return \"string\";\n      };\n      closure.isInAttribute = true;\n      return closure;\n    }\n\n    function inBlock(style, terminator) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      }\n    }\n\n    function doctype(depth) {\n      return function(stream, state) {\n        var ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n        return \"meta\";\n      };\n    }\n\n    function lower(tagName) {\n      return tagName && tagName.toLowerCase();\n    }\n\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName || \"\";\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n        this.noIndent = true;\n    }\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n        parentTagName = state.context.tagName;\n        if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) ||\n            !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {\n          return;\n        }\n        popContext(state);\n      }\n    }\n\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return attrState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName &&\n            config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))\n          popContext(state);\n        if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return closeState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n      popContext(state);\n      return baseState;\n    }\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName, tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n        if (type == \"selfcloseTag\" ||\n            config.autoSelfClosers.hasOwnProperty(lower(tagName))) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n        return baseState;\n      }\n      setStyle = \"error\";\n      return attrState;\n    }\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n\n    return {\n      startState: function(baseIndent) {\n        var state = {tokenize: inText,\n          state: baseState,\n          indented: baseIndent || 0,\n          tagName: null, tagStart: null,\n          context: null}\n        if (baseIndent != null) state.baseIndent = baseIndent\n        return state\n      },\n\n      token: function(stream, state) {\n        if (!state.tagName && stream.sol())\n          state.indented = stream.indentation();\n\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle)\n            style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n        return style;\n      },\n\n      indent: function(state, textAfter, fullLine) {\n        var context = state.context;\n        // Indent multi-line strings (e.g. css).\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented)\n            return state.stringStartCol + 1;\n          else\n            return state.indented + indentUnit;\n        }\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText)\n          return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n        // Indent the starts of attribute names.\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false)\n            return state.tagStart + state.tagName.length + 2;\n          else\n            return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n        if (tagAfter && tagAfter[1]) { // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) { // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[lower(context.tagName)];\n            if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))\n              context = context.prev;\n            else\n              break;\n          }\n        }\n        while (context && context.prev && !context.startOfLine)\n          context = context.prev;\n        if (context) return context.indent + indentUnit;\n        else return state.baseIndent || 0;\n      },\n\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n\n      skipAttribute: function(state) {\n        if (state.state == attrValueState)\n          state.state = attrState\n      },\n\n      xmlCurrentTag: function(state) {\n        return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n      },\n\n      xmlCurrentContext: function(state) {\n        var context = []\n        for (var cx = state.context; cx; cx = cx.prev)\n          context.push(cx.tagName)\n        return context.reverse()\n      }\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n    CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n"]}